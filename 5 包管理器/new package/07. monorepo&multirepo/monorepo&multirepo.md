# monorepo&multirepo

无论是monorepo还是multirepo，都是在面对**多个项目**的时候一套项目代码管理的方案。

mono 是英语里面“单一的、单独的”，repo 是“repository”单词的简写，表示“仓库”的意思。

因此 monorepo 指的就是使用单一仓库来管理多个项目。



首先我们需要搞清楚，什么算是一个仓库？

一般来讲，一个仓库是指通过版本控制系统（git）进行管理的代码库。在 git 的上下文中，一个仓库通常是指一个包含 .git 子目录的目录。.git 这个目录通常包含了所有版本的提交历史、分支以及标签等信息。

因此，一个通过 git 初始化后的目录才算是一个仓库。



- monorepo指的是使用单一仓库管理多个项目
- multirepo（polyrepo）指的是使用多个仓库管理多个项目，通常就是一个项目对应一个仓库

![16853224035558](https://resource.duyiedu.com/xiejie/2023-05-30-022814.jpg)

monorepo 这种多项目的管理方式，乍看之下是反直觉的。因为我们会下意识的认为多个项目就应该对应多个仓库，但是随着公司业务的发展，往往类似的项目会越来越多，一个项目对应一个仓库往往会存在以下的一些弊端：

- 每个项目都要搭建 *eslint + prettier + commitLint + styleLint* 等代码规范校验
- 每个项目都要搭建许多类似的常用组件和创建公共 *utils* 函数
- 各个项目的主要依赖库（*vue*、*elementPlus*）版本可能不一致，且存在重复安装
- 有时候组件改动会涉及到多个项目都要手动更改

考虑到我们在不同的项目的业务中，往往会使用到公共的组件库以及公共的依赖，那么采用 monorepo 风格来管理多个项目就比较合适了。monorepo 可以让多个模块共享同一个仓库，因此它们可以共享同一套构建流程、代码规范，这些都是可以做到统一的，特别是如果存在公共的组件或者工具函数的情况下，查看代码、修改 bug、调试这些都会变得非常的方便。

目前很多知名的公司都是采用 monorepo 风格来管理公司内部的多个项目：

- 谷歌（*Google*）：谷歌是使用 *monorepo* 的著名代表之一。他们将所有项目和库存储在一个称为 *Piper* 的庞大代码库中。这使得他们能够更容易地管理依赖关系、共享代码并跨项目进行更改。

- *Meta*：*Meta* 也采用了 *monorepo* 策略。他们的代码库包括了多个项目，如 *React、React Native* 和 *Jest* 等。这有助于他们统一管理这些项目的代码和依赖关系。

- 微软（*Microsoft*）：虽然微软在某些方面使用了多代码库策略，但他们在一些项目中也采用了 *monorepo*。例如，他们的 *Windows* 操作系统和 *Visual Studio* 代码编辑器都使用 *monorepo* 进行管理。

- *Twitter*：*Twitter* 也是 *monorepo* 的支持者，他们将所有代码存储在一个称为 *Pants* 的代码库中。这有助于他们更好地管理依赖关系和提高代码复用率。

- *Uber*：*Uber* 使用一个名为 “*Fusion.js*”的 *monorepo* 代码库来管理他们的许多前端项目。这使他们能够更有效地共享代码和跨项目进行更改。

使用 monorepo 风格来管理多项目，主要的好处就是代码共享，这里还可以罗列出一些其他的好处：

- 统一的依赖管理：在 *monorepo* 中，所有项目和库的依赖关系都在同一个地方进行管理。这有助于减少版本冲突和依赖问题。团队可以更容易地保持依赖关系的一致性和更新。

- 简化代码共享：由于所有项目都在同一个代码库中，开发人员可以轻松地共享代码和资源。这有助于提高代码复用率和降低维护成本。

- 更容易进行跨项目更改：在 *monorepo* 中，对多个项目进行协调更改变得更加简单，因为所有项目都在同一个地方。这降低了跨项目更改的复杂性和风险。

- 更好的跨团队协作：*monorepo* 有助于提高团队之间的协作效率，因为开发人员可以轻松地查看其他项目的代码和进度。



在企业开发中，如果你选择使用 monorepo 风格来管理你的多个项目，那么通常是将公共的组件、工具库、api 进行一个抽离共享

![16853443595538](https://resource.duyiedu.com/xiejie/2023-05-30-024153.jpg)

但是这里要说一下，monorepo 这种风格去管理多个项目，不是说都是优点，也存在一些缺点的。

- 代码库的规模：随着项目数量的增加，那么我们的代码库就会变得非常的庞大。
- 缺乏独立版本的控制：所有项目共享相同的提交历史，可能会导致独立版本的控制变得非常复杂。
- 权限和安全性问题：由于所有项目都是在同一个代码库里面，权限控制会变得比较困难，安全性就会变得弱一些。
- 工具和基础设施的要求：随着项目数量的增加，代码库肯定是会越来越大的，这个时候就需要一些特定的工具以及基础设施来辅助管理，例如谷歌就用了自定义的代码库以及构建系统来管理它们庞大的monorepo



因此我们在考虑管理多个项目的时候，不是说直接无脑使用 monorepo 风格就行了，需要基于你工作的实际场景以及需求来确定。

一般来讲，以下的情况你可以考虑使用 monorepo：

1. 当项目之间有很多共享代码和资源时：*monorepo* 可以使代码共享变得更加简单，有助于提高代码复用率。

2. 当团队需要频繁进行跨项目协作时：*monorepo* 有助于提高团队之间的协作效率，尤其是在需要跨项目进行更改的情况下。

3. 当统一依赖管理对项目至关重要时：如果项目之间的依赖关系管理具有很高的优先级，*monorepo* 可以提供更好的依赖管理解决方案。



理解了 monorepo 的概念后，multirepo 的概念也就很简单了，就是不同的项目对应独立的仓库。在这种情况下，每个项目和库都会有自己的版本控制历史和依赖关系。

- 独立版本控制：每个项目和库可以独立跟踪其版本控制历史，使得版本控制更加清晰。

- 更小的代码库规模：由于每个项目和库都有自己的代码库，因此每个代码库的规模相对较小，便于管理和克隆。

- 更高的项目自治：每个项目和库都可以根据自己的需求选择技术栈和依赖管理策略，提高项目的灵活性。

当然 multirepo 的缺点就是代码共享会变得困难一些。

下面有一张表对比了两个多项目代码管理风格的区别：



|          | *monorepo*                                                   | *multirepo*                                                  |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 开发     | 只需要在一个仓库中开发，编码方便，新成员入门简单             | 仓库体积小，模块划分清晰。                                   |
| 复用     | 代码复用高，方便进行代码重构                                 | 需要多仓库来回切换，无法实现跨项目代码复用                   |
| 工程配置 | 所有项目统一使用相同的工程配置                               | 各个项目可能有一套单独标准                                   |
| 依赖管理 | 共同依赖可以提升到 *root*，版本控制更加容易，依赖管理会变得更方便 | 不同的项目会安装相同的依赖，但即便相同的依赖会存在版本不同的情况 |
| 代码管理 | 代码全在一个仓库，项目太大用 *git* 管理会存在问题，无法隔离项目代码权限 | 各个团队可以控制代码权限，也几乎不会有项目太大的问题         |
| 部署     | 有 *lerna* 工具支持                                          | 如果多项目存在依赖关系，开发就需要在不同的仓库按照依赖先后顺序去修改版本以及进行部署 |

