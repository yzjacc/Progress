# mongoose中的并发管理

![image-20200602172616148](http://mdrs.yuanjin.tech/img/image-20200602172616148.png)

当多个异步函数同时操作数据库时，就可能发生这样的情况，具体的场景往往发生在并发请求中

面对这种情况，`mongoose`作出以下假设：

- 当修改一个文档时，如果某些字段已经不再和数据库对应，说明这个字段的数据是脏数据（dirty data），对于脏数据，不应该对数据库产生影响
- 当修改一个文档时，如果字段和数据库是对应的，则是正常数据，正常数据可以正常的更改数据库



因此，`mongoose`对于上述场景的处理如下：

![image-20200602172739999](http://mdrs.yuanjin.tech/img/image-20200602172739999.png)

可以看出，对于`user2`的修改，`name`和`loginId`是脏数据，因此不会更新到数据库中，而`age`是正常数据，对它的更改会应用到数据库

然而，`mongoose`无法准确的判定对数组是否是脏数据，因此，如果遇到数组的修改，`mongoose`会做出如下处理：

- 当新增文档时，会自动添加字段`__v`，用于记录更新版本号，一开始为`0`
- 通过模型实例对数组进行修改后，保存时会在内部调用实例的`increment`函数，将版本号`+1`
- 当其他模型实例也更改了数组，保存时会对比版本号，如果不一致，则会引发`VersionError`

原理图如下：

![image-20200602183628001](http://mdrs.yuanjin.tech/img/image-20200602183628001.png)



出现错误是好事，可以提醒开发者：这一次保存的某些数据是脏数据，应该引起重视。开发者可以灵活的根据具体情况作出处理，比如提示用户保存失败，或者重新获取数据然后保存。

由于`mongoose`仅针对数组进行版本控制，如果要针对所有字段都进行版本控制，需要使用`mongoose`的插件：`mongoose-update-if-current`

> 插件地址：https://github.com/eoin-obrien/mongoose-update-if-current
>
> 该插件有一个`bug`，需要手动解决

使用插件后，所有的字段都将受到版本控制，一旦版本不一致，将引发`VersionError`

