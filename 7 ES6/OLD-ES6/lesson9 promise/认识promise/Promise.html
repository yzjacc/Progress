<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <!-- <script src='./Promise.js'></script> -->
    <script>
        // Promise
        // executor function 同步执行
        // Promise 承诺
        // Deferred 
        // done    fail    progress
        // resolve reject  notify
        // pending  onFulfilled onRejected
        // setTimeout(() => {
        //     console.log('setTime');
        // }, 0);
        // let oP = new Promise((resolve, reject) => {
        //     // 异步操作
        //     // setTimeout(() => {
        //     //     Math.random() * 100 > 60 ? resolve('ok') : reject('no');
        //     // }, 1000);
        //     console.log(0);
        //     resolve(1);
        // });
        // console.log(1);

        // then
        // 异步执行
        // setTimeout()
        // 
        // 宏任务              微任务
        // task queue 1     task queue 2
        // 微任务有优先 执行权
        // jq 你不知道的js UI 多线程
        // oP.then((val) => {
        //     console.log(val);
        // }, (reason) => {
        //     console.log(reason);
        // });

        // console.log(2);

        // 1 2 1 setTime



        // let oP = new Promise((resolve, reject) => {
        //     // 异步操作
        //     // setTimeout(() => {
        //     //     Math.random() * 100 > 60 ? resolve('ok') : reject('no');
        //     // }, 1000);
        //     resolve('ok');
        // });
        // 链式操作
        // 上一个不抛出错误的话，那下一个then执行成功的函数

        // 返回值作为下一个then注册函数的执行参数

        // 返回值 Promise 对象

        // 上一个then 注册的函数抛出错误 下一个then的失败回调就会执行

        // oP.then((val) => {
        //    console.log(val);
        //    throw new Error('duyi');
        // //    return new Promise((resolve, reject) => {
        // //         reject('newPromise ok');
        // //    });
        // }, (reason) => {
        //    console.log(reason);
        //    return 30;
        // }).then((val) => {
        //     console.log('ok then2:' + val);
        // }, (reason) => {
        //     console.log('no then2:' + reason);
        // });

        

        let oP = new Promise((res, rej) => {
            // throw new Error('duyi');
            res();
        });
        // 链式调用的时候如果写一个空then其实相当于不存在可以忽视
        oP.then(() => {
            throw new Error('duyi');
        }, (reason) => {
            console.log(reason)
        }).then().then(() => {

        }).then(null, (reason) => {
            console.log(reason)
        }).catch((err) => {
            console.log(98, err);
            return 10;
        }).then((val) => {
            console.log('catch after ok:' + val)
        }, (reason) => {
            console.log('catch after no:' + reason)
        }).finally(() => {
            console.log('over')
        });

        // 
        // $.when
        
    </script>
</body>
</html>